#![allow(unused_imports)]

use {
    crate::{
        error::ErrorCode,
    },
    context::*,
    state::*,
    utils::{MAXIMUM_MERKLE_DEPTH, MAX_HISTORY},
    anchor_lang::prelude::*,
    anchor_spl::token::{self, Transfer, CloseAccount},
};

pub mod context;
pub mod error;
pub mod state;
pub mod utils;

declare_id!("spLit2eb13Tz93if6aJM136nUWki5PVUsoEjcUjwpwW");

#[program]
pub mod splitter_token {
use super::*;

    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        name: String,       // The name of the treasury pool
        levels: u8,         // Depth of the merkle tree
    ) -> Result<()> {
        if levels as usize > MAXIMUM_MERKLE_DEPTH {
            return err!(ErrorCode::InvalidMerkleTreeDepth);
        }

        ctx.accounts.pool.data_version = state::DataVersion::Version1;
        ctx.accounts.pool.authority = ctx.accounts.authority.key();
        ctx.accounts.pool.mint = ctx.accounts.mint.key();
        ctx.accounts.pool.vault = ctx.accounts.vault.key();
        ctx.accounts.pool.vault_bump = *ctx.bumps.get("vault").unwrap();
        ctx.accounts.pool.name = name;

        // Calculate the initial state of the merkle tree
        ctx.accounts.pool.merkle_tree = MerkleTree::new(&[
            utils::PREFIX_MERKLE_TREE.as_bytes(),
            ctx.accounts.pool.to_account_info().key.as_ref(),
        ], levels);


        // Initialize the blockhash list with the current merkle root as the first blockhash
        ctx.accounts.pool.current_index = 0;
        ctx.accounts.pool.history_list = vec![ctx.accounts.pool.merkle_tree.root; MAX_HISTORY as usize];

        Ok(())
    }

    pub fn save_recent_root(
        ctx: Context<SaveRecentRoot>,
        _pool_bump: u8,
    ) -> Result<()> {

        let recent_root = ctx.accounts.pool.merkle_tree.root;

        // Check if the history list already contains the current merkle root
        if !(ctx.accounts.pool.history_list.contains(&recent_root)) {

            // Save the root to the history list at the next circular index
            let index = (ctx.accounts.pool.current_index + 1) % MAX_HISTORY;
            ctx.accounts.pool.current_index = index;
            ctx.accounts.pool.history_list[index as usize] = recent_root;
        }

        Ok(())
    }

    pub fn transfer_with_commitment(
        ctx: Context<TransferWithCommitment>, 
        _pool_bump: u8,
        amount: u64,            // amount to deposit
        _transcript: [u8; 32],  // a 32-byte hash of the private payment intent data
        recent_root: [u8; 32]   // a recent merkle root
    ) -> Result<()> {

        // Check that the provided blockhash is valid
        let constraint = ctx.accounts.pool.history_list.contains(&recent_root);
        if !constraint {
            return err!(ErrorCode::InvalidRecentRoot);
        }

        let seeds = [
            utils::PREFIX_POOL_VAULT.as_bytes(),
            ctx.accounts.pool.to_account_info().key.as_ref(),
            &[ctx.accounts.pool.vault_bump],
        ];
        let signer = &[&seeds[..]];

        let cpi_accounts = Transfer {
            from: ctx.accounts.vault.to_account_info().clone(),
            to: ctx.accounts.destination.to_account_info().clone(),
            authority: ctx.accounts.vault.to_account_info().clone(),
        };

        let cpi_program = ctx.accounts.token_program.to_account_info().clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::transfer(cpi_ctx, amount)?;

        // Add the commitment address to the merkle tree
        let leaf = ctx.accounts.commitment.key().as_ref().try_into().unwrap();
        ctx.accounts.pool.merkle_tree.add_leaf(leaf)?;

        Ok(())
    }

    pub fn initialize_proof(
        ctx: Context<InitializeProof>,
        pool_bump: u8,
        merkle_root: [u8; 32],    // A recent root that was generated by the pool
        commitment: Pubkey        // The PDA we're going to prove is part of the recent blockhash
    ) -> Result<()> {

        ctx.accounts.proof.data_version = state::DataVersion::Version1;
        ctx.accounts.proof.pool = ctx.accounts.pool.key();
        ctx.accounts.proof.pool_bump = pool_bump;
        ctx.accounts.proof.merkle_root = merkle_root;
        ctx.accounts.proof.commitment = commitment;
        ctx.accounts.proof.verified = false;
        ctx.accounts.proof.data = vec![];
        ctx.accounts.proof.size = 0;

        Ok(())
    }

    pub fn upload_proof(
        ctx: Context<UploadProof>,
        _pool_bump: u8,
        _proof_bump: u8,
        _current_size: u8,
        _data_size: u8,
        data: Vec<[u8; 32]>,
    ) -> Result<()> {

        // Append the data to the proof
        ctx.accounts.proof.data.extend_from_slice(&data);
        ctx.accounts.proof.size += data.len() as u8;

        Ok(())
    }

    pub fn verify_proof(
        ctx: Context<VerifyProof>,
        _pool_bump: u8,
        _proof_bump: u8
    ) -> Result<()> {

        // Check that the merkle proof is valid
        if MerkleTree::verify(
            &ctx.accounts.proof.data,
            ctx.accounts.proof.merkle_root,
            ctx.accounts.proof.commitment.as_ref().try_into().unwrap()) {

            // Mark the proof as valid
            ctx.accounts.proof.verified = true;
        } else {
            return err!(ErrorCode::InvalidProof);
        }

        Ok(())
    }

    pub fn close_proof(
        _ctx: Context<CloseProof>,
        _pool_bump: u8,
        _proof_bump: u8,
    ) -> Result<()> {

        // Nothing to do here
        Ok(())
    }

    pub fn open_token_account(
        _ctx: Context<OpenTokenAccount>,
        _pool_bump: u8,
        _proof_bump: u8,
    ) -> Result<()> {

        msg!("open_token_account: {}", _ctx.accounts.commitment_vault.key());

        // Nothing to do here
        Ok(())
    }

    pub fn close_token_account(
        ctx: Context<CloseTokenAccount>,
        _pool_bump: u8,
        _proof_bump: u8,
        vault_bump: u8,
    ) -> Result<()> {
        let seeds = [
            utils::PREFIX_COMMITMENT_VAULT.as_bytes(),
            ctx.accounts.pool.to_account_info().key.as_ref(),
            ctx.accounts.proof.commitment.as_ref(),
            &[vault_bump],
        ];
        let signer = &[&seeds[..]];

        let cpi_accounts = Transfer {
            from: ctx.accounts.commitment_vault.to_account_info().clone(),
            to: ctx.accounts.pool_vault.to_account_info().clone(),
            authority: ctx.accounts.commitment_vault.to_account_info().clone(),
        };

        // It is possible for the close instruction to fail if someone else
        // deposits into the commitment vault (in case the amount is larger)
        // So... we need to take the full amount
        let amount = ctx.accounts.commitment_vault.amount;

        let cpi_program = ctx.accounts.token_program.to_account_info().clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::transfer(cpi_ctx, amount)?;

        // The close trait is used in the Settle context so Anchor will close
        // the commitment account for us. We can't do the same for the vault
        // account though because anchor doesn't know how to sign the CPI
        // properly for that.

        // Manually close the vault account.
        let cpi_accounts = CloseAccount {
            account: ctx.accounts.commitment_vault.to_account_info().clone(),
            destination: ctx.accounts.authority.to_account_info().clone(),
            authority: ctx.accounts.commitment_vault.to_account_info().clone(),
        };

        let cpi_program = ctx.accounts.token_program.to_account_info().clone();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::close_account(cpi_ctx)?;

        Ok(())
    }
}


